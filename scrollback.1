.TH scrollback 1 "Nov 28, 2020"

.
.
.SH NAME

scrollback - a scrollback buffer for Linux virtual terminals

.
.
.
.SH SYNOPSIS

.TP 11
.B scrollback
[\fI-b buffersize\fP]
[\fI-u\fP]
[\fI-s\fP]
[\fI-v\fP]
[\fI-c\fP]
[\fI-d level\fP]
[\fI-h\fP]
.I /path/to/shell

.
.
.
.SH DESCRIPTION

When run in a Linux virtual terminal,
.I
scrollback
runs a shell with a scrollback buffer. Text scrolled out of the screen is
shown by either \fIF11\fP or \fIShift-PageUp\fP, depending on the key
configuration, described below. Scrolling down is done by \fIF12\fP or
\fIShift-PageDown\fP.

.
.
.
.SH OPTIONS

.TP
.BI -b " buffersize
set the size of the buffer, the number of characters it contains

.TP
.B
-u
run on a terminal that is in unicode mode;
the default is to autodetect from the current locale

.TP
.B
-s
run on a terminal that is not in unicode mode;
the default is to autodetect from the current locale

.TP
.B
-v
do not make a file descriptor of the console available to the shell and the
called programs through the \fIVT_FILENO\fP environment variable; see
\fIDIRECT ACCESS TO THE VIRTUAL TERMINAL\fP, below

.TP
.B
-c
only check whether \fIscrollback\fP would run; it does from a
Linux console different than \fItty6\fP and only if the environment variable
\fISCROLLBACK\fP is not set; it does not run, for example, within itself

.TP
.B
-k
configure
.I
Shift-PageUp
and
.I
Shift-PageDown
to be used by all subsequent runs

.TP
.BI -d " level
the debug level, the inclusive or of:
1, to log data exchanged between the shell and the actual terminal to a file
\fIlogescape\fP;
2, to continuosly save the status of the scrollback buffer to a file
\fIlogfile\fP;
4, to debug the key assignment procedure

.TP
.B
-h
inline help

.
.
.
.SH KEY CONFIGURATION

.I
scrollback
uses \fIShift-PageUp\fP and \fIShift-PageDown\fP for scrolling in the buffer if
these keys are available. This is the case when they are associated to some
strings by \fIloadkeys(1)\fP. An easy way to do that is to call
.I
scrollback -k
at startup as root. The service file \fIscrollback.service\fP allows doing
that from \fIsystemctl(1)\fP.

.
.
.
.SH AUTOMATIC STARTUP

Running \fIscrollback\fP from a shell initialization file such as \fI.bashrc\fP
is possible but requires some care. Since \fIscrollback\fP calls the shell
itself, its initialization file would be processed again, resulting in an
infinite loop of calls to \fIscrollback\fP.

This is avoided by using the following in \fI.bashrc\fP:

.nf
.I
  ! $SCROLLBACK false && [ $(tty) != /dev/tty6 ] && \\
.I
  scrollback -c /bin/bash && exec scrollback /bin/bash
.fi

The evironment variable \fISCROLLBACK\fP is set by \fIscrollback\fP itself to
true. The first part of the line ensures that the program will not call itself.

Since the command \fIexec scrollback /bin/bash\fP makes \fIscrollback\fP
replace the current shell (the one that is executing \fI.bashrc\fP), a failure
would close it without running the other shell from within \fIscrollback\fP.

The test \fI[ $(tty) != /dev/tty6 ]\fP is a
fallback to make logging in always possible from the sixth virtual terminal
(switched in by \fIControl-Alt-F6\fP).

Calling \fIscrollback -c /bin/bash\fP is a test for whether \fIscrollback\fP
would refuse to run, for example because it is not running on a Linux virtual
terminal. It avoids the following \fIexec\fP in this case.

.
.
.
.SH DIRECT ACCESS TO THE VIRTUAL TERMINAL

\fIscrollback\fP creates a pseudoterminal and runs the shell in it, forwarding
data back and forth between the pseudoterminal and the actual virtual terminal.

The shell and all programs executed from it run in the pseudoterminal, for
example \fI/dev/pts/0\fP. As long as they only exchange text with the
pseudoterminal (read and write) this sufficies because \fIscrollback\fP
forwards it between \fI/dev/pts/0\fP and the actual virtual terminal, for
example \fI/dev/tty1\fP.

However, the \fIioctl(2)\fP calls on the pseudoterminal cannot be forwarded.
The functions described in \fIioctl_console(2)\fP for \fI/dev/tty1\fP do not
work on \fI/dev/pts/0\fP. Opening \fI/dev/tty1\fP do not work either because
access to it is denied by the operating system.

A program can still access the actual virtual terminal in three ways:

.IP "  * " 4
the program calls \fIioctl(2)\fP on the open file descriptor whose number is
stored in the environment variable \fIVT_FILENO\fP, available unless
\fIscrollback\fP is called with option \fI-v\fP:

.nf
\fI
	char *vtstring;
	int vtno;
	char leds;

	...
	vtstring = getenv("VT_FILENO");
	if (vtstring)
		vtno = atoi(vtstring);
	else {
		vtno = STDIN_FILENO;
		// or
		vtno = open("/dev/tty", O_RDWR);
	}
	...
	ioctl(vtno, KDGETLED, &leds);
\fP
.fi

.IP "  * "
the program is run through the \fIvtwrapper\fP script:

.nf
.I
	vtwrapper program arg1 arg2...
.fi

this works if the program calls \fIioctl(2)\fP on a standard file descriptor,
either \fI0\fP, \fI1\fP or \fI2\fP, since what \fIvtwrapper\fP does is to make
them a copy of \fIVT_FILENO\fP

.IP "  * "
the program is called via \fIvtdirect\fP:

.nf
.I
	vtdirect "program arg1 arg2..."
.fi

this runs program directly on the virtual terminal; this is necessary to run
\fIstartx(1)\fP, for example

.P
In the latter two cases, text produced by the program does not go in the
scrollback buffer and cannot therefore be later retrieved by scrolling up.

